name: OWASP ZAP Scan

on:
  push:
    branches: [ main ]
  workflow_dispatch: # Allows manual triggering of the workflow

jobs:
  security:
    name: OWASP ZAP Baseline Scan
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          # Fetch all history for accurate commit SHA for image tagging
          fetch-depth: 0

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'npm' # Cache npm dependencies for faster builds

      - name: Install Node.js dependencies
        run: npm install

      - name: Create Docker network for testing
        # A dedicated network allows containers to communicate by name (e.g., 'test-app').
        run: docker network create zap-net

      - name: Build Node.js app Docker image
        # Build your Node.js application into a Docker image.
        # Tag it with 'my-node-app-for-scan' for easy reference within the workflow.
        run: docker build -t my-node-app-for-scan .

      - name: Run app container on zap-net network
        # Run the application container in detached mode (-d) and assign it a name 'test-app'.
        # Connect it to the 'zap-net' network.
        # Map port 3000 inside the container to port 3000 on the host (though ZAP will use internal network).
        run: docker run -d --rm --name test-app --network zap-net -p 3000:3000 my-node-app-for-scan

      # --- Start Debugging Steps for App Startup ---
      - name: Check running Docker containers
        # List all Docker containers (even stopped ones) to see the status of 'test-app'.
        # This helps confirm if the container started and is still running.
        run: docker ps -a

      - name: Get app container logs
        # Fetch and print the logs from the 'test-app' container.
        # This is crucial for identifying any errors during your Node.js app's startup.
        run: docker logs test-app
        # Continue even if logs command fails (e.g., container exited too quickly)
        continue-on-error: true
      # --- End Debugging Steps for App Startup ---

      - name: Download wait-for-it.sh
        # Download 'wait-for-it.sh', a utility to wait for a service to be available.
        # This is crucial to ensure the Node.js app is fully started before ZAP attempts to scan.
        run: |
          curl -sSL https://raw.githubusercontent.com/vishnubob/wait-for-it/master/wait-for-it.sh -o wait-for-it.sh
          chmod +x wait-for-it.sh

      - name: Wait for Node.js app to start
        # Use wait-for-it.sh to poll 'test-app' on port 3000.
        # It will retry for up to 60 seconds. If the app doesn't respond, the workflow will fail.
        run: ./wait-for-it.sh test-app:3000 --timeout=60 --strict -- echo "Node.js app is up and running!"

      # --- Start OWASP ZAP Baseline Scan Steps ---
      - name: Pull OWASP ZAP Docker image
        # Explicitly pull the ZAP stable image to ensure it's available.
        run: docker pull ghcr.io/zaproxy/zaproxy:stable

      - name: Prepare ZAP working directory permissions
        # Set broad permissions on the current GitHub Actions workspace.
        # This allows the ZAP container (which runs as a non-root user) to write scan reports
        # and its configuration file (zap.yaml) into the mounted volume.
        # This step is still useful if ZAP attempts to write any temporary files,
        # even if explicit reports are not generated.
        run: |
          chmod -R 777 .

      - name: Run OWASP ZAP baseline scan
        # Directly execute the ZAP baseline scan Docker container.
        # Removed -J, -w, -r flags to prevent report generation.
        # ZAP will now output scan results directly to the console logs.
        run: |
          docker run \
            -v ${{ github.workspace }}:/zap/wrk/:rw \
            --network zap-net \
            -t ghcr.io/zaproxy/zaproxy:stable \
            zap-baseline.py \
            -t http://test-app:3000
      # --- End OWASP ZAP Baseline Scan Steps ---

      - name: Cleanup app container and network
        # Always run this step to ensure Docker resources are cleaned up,
        # regardless of whether previous steps succeeded or failed.
        if: always()
        run: |
          docker rm -f test-app || true # Force remove if still running
          docker network rm zap-net || true # Remove the custom network
